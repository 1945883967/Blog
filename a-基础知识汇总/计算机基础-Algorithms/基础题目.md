# 基础题目

## Array

#### [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

```java
public void moveZeroes(int[] nums) {
    int j = 0;
    for (int i = 0; i < nums.length; i++) {
        if(nums[i] != 0){
            nums[j] = nums[i];
            if(i != j){
                nums[i] = 0;
            }
            j++;
        }
    }
}
```

> 一维数组的坐标变换 j，i

#### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

```java
public int maxArea(int[] a) {
    int max = 0;
    for(int i = 0, j = a.length - 1; i < j;){
        int minHeight = a[i] < a[j] ? a[i++] : a[j--];
        int area = (j - i + 1) * minHeight;
        max = Math.max(max, area);
    }
    return max;
}
```

> 双指针

#### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

```java
public int climbStairs(int n) {
    if(n <= 2) return n;
    int a = 1, b= 2, c = 0;
    for(int i = 2; i < n; i++){
        c = a + b;
        a = b;
        b = c;
    }
    return c;
}
```

#### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

* 时间复杂度：O(N^2)

* 空间复杂度：O(1)

```java
public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> list = new ArrayList<>();
    Arrays.sort(nums);
    for(int k = 0; k < nums.length -2; k++) {
        if(nums[k] > 0)  return list;
        if(k > 0 && nums[k] == nums[k-1]) continue;
        // 双指针
        int L = k + 1, R = nums.length -1;
        while (L < R) {
            int sum = nums[k] + nums[L] + nums[R];
            if(sum < 0) {
                L++;
            } else if (sum > 0) {
                R--;
            } else {
                list.add(Arrays.asList(nums[k], nums[L], nums[R]));
                while (L < R && nums[L] == nums[L+1]) L++;
                while (L < R && nums[R] == nums[R-1]) R--;
                L++;R--;
            }
        }
    }
    return list;
}
```

#### [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

* 时间复杂度：O(N)
* 空间复杂度：O(1)

```java
public int removeDuplicates(int[] nums) {
    int n = nums.length;
    if (n == 0) return 0;
    int slow = 1, fast = 1;
    while (fast < n) {
        if (nums[fast] != nums[fast -1]) {
            nums[slow++] = nums[fast];
        }
        fast++;
    }
    return slow;
}
```



## LinkList

#### [链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

* 时间复杂度：O(N)
* 空间复杂度：O(1)

```java
public ListNode getKthFromEnd(ListNode head, int k) {
    ListNode former = head, latter = head;
    for(int i = 0; i < k; i++)
        former = former.next;
    while(former != null) {
        former = former.next;
        latter = latter.next;
    }
    return latter;
}
```

#### [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

* 时间复杂度：O(N)
* 空间复杂度：O(1)

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    if(head == null || n <= 0) {
        return null;
    }
    ListNode p = new ListNode(0, head);
    ListNode fast = head, slow = p;
    for(int i = 0; i < n; i++) {
        fast = fast.next;
    }
    while(fast != null) {
        fast = fast.next;
        slow = slow .next;
    }
    slow.next = slow.next.next;
    return p.next;
}
```

#### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

```java
public ListNode reverseList(ListNode head) {
    ListNode pre = null, next = null;
    while(head != null) {
        next = head.next;
        head.next = pre;
        pre = head;
        head = next;
    }
    return pre;
}
```

#### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

**递归**

```java
public ListNode swapPairs(ListNode head) {
    if(head == null || head.next == null) {
        return head;
    }
    ListNode next = head.next;
    head.next = swapPairs(next.next);
    next.next = head;
    return next;
}
```

**非递归**

```java

```

#### [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

**解法一**：

* 时间复杂度：O(N)

* 空间复杂度：O(1)

```java
public boolean hasCycle(ListNode head) {
    if (head == null || head.next == null) {
        return false;
    }
    ListNode slow = head;
    ListNode fast = head.next;
    while (slow != fast) {
        if(fast == null || fast.next == null) {
            return false;
        }
        fast = fast.next.next;
        slow = slow.next;
    }
    return true;
}
```

**解法二**：

* 时间复杂度：O(N)

* 空间复杂度：O(N)

```java
public boolean hasCycle(ListNode head) {
    Set<ListNode> set = new HashSet<>();
    while (head != null) {
        if(!set.add(head)) {
            return true;
        }
        head = head.next;
    }
    return false;
}
```

#### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

* 时间复杂度：O(N)

* 空间复杂度：O(1)

```java
// 解法1 相比第二中解法，确实精炼
public ListNode detectCycle(ListNode head) {
    if(head == null || head.next == null) {
        return  null;
    }
    ListNode fast = head, slow = head, start = head;
    while (fast.next != null && fast.next.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if(slow == fast) {
            while (slow != start) {
                slow = slow.next;
                start = start.next;
            }
            return start;
        }
    }
    return null;
}
// 解法2
public ListNode detectCycle(ListNode head) {
    if (head == null || head.next == null){
        return null;
    }
    ListNode fast = head;
    ListNode slow = head;
    ListNode start = head;
    while(true) {
        if (fast.next != null && fast.next.next != null){
            fast = fast.next.next;
        } else {
            return null;
        }
        slow = slow.next;
        if (slow == fast) {
            break;
        }
    }
    while(true) {
        if (start != fast) {
            start = start.next;
            fast = fast.next;
        } else {
            break;
        }
    }
    return start;
}
```

#### [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)





## Stack&Queue

#### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

```java
public boolean isValid(String s) {
    Stack<Character> stack = new Stack<>();
    for(Character c : s.toCharArray()) {
        if(c == '(') 
            stack.push(')');
        else if(c == '[')
            stack.push(']');
        else if(c == '{')
            stack.push('}');
        else if(stack.isEmpty() || stack.pop() != c)
            return false;
    }
    return stack.isEmpty();
}
```

#### [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

* 时间复杂度：O(1)
* 空间复杂度：O(N)

```java
import java.util.Stack;

public class MinStack {
    private Stack<Integer> dataStack;
    private Stack<Integer> minStack;

    /** initialize your data structure here. */
    public MinStack() {
        this.dataStack = new Stack<>();
        this.minStack = new Stack<>();
    }

    public void push(int val) {
        if(this.minStack.isEmpty() || val <= this.getMin()) {
            this.minStack.push(val);
        }
        dataStack.push(val);
    }

    public int pop() {
        if(this.dataStack.isEmpty()) {
            throw new RuntimeException("Stack is empty");
        }
        int val = this.dataStack.pop();
        if(val == this.minStack.peek()) {
            this.minStack.pop();
        }
        return val;
    }

    public int top() {
        if(this.dataStack.isEmpty()) {
            throw new RuntimeException("Stack is empty");
        }
        return  dataStack.peek();
    }

    public int getMin() {
        if(this.minStack.isEmpty()) {
            throw new RuntimeException("Stack is empty");
        }
        return this.minStack.peek();
    }
}
```

#### [84. 柱状图中最大的矩形 ](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/) :running:

* 时间复杂度：
* 空间复杂度：

#### [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

* 时间复杂度：O(N)
* 空间复杂度：O(N)

```java
public int[] maxSlidingWindow(int[] arry, int w) {
    if(arry == null || w < 1 || arry.length < w){
        return null;
    }
    LinkedList<Integer> qmax = new LinkedList<>();
    int[] res = new int[arry.length - w  + 1];
    int index = 0;
    for(int i  = 0 ; i < arry.length; i++){
        while (!qmax.isEmpty() && arry[i] >= arry[qmax.peekLast()]){
            qmax.pollLast();
        }
        qmax.addLast(i);
        if(qmax.peekFirst() == i - w){
            qmax.pollFirst();
        }
        if(i >= w -1){
            res[index++] = arry[qmax.peekFirst()];
        }
    }
    return res;
}
```

## Map

#### [242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

* 时间复杂度：O(N)
* 空间复杂度：O(N)

```java
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) {
        return false;
    }
    int[] table = new int[26];
    for (char c : s.toCharArray()) {
        table[c - 'a']++;
    }
    for (char c : t.toCharArray()) {
        table[c - 'a']--;
        if (table[c - 'a'] < 0) {
            return false;
        }
    }
    return true;
}
```

#### [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

* 时间复杂度：O(nklogk)
* 空间复杂度：O(nk)

```java
public List<List<String>> groupAnagrams(String[] strs) {
    Map<String, List<String>> map = new HashMap<>();
    for (String str : strs) {
        char[] array = str.toCharArray();
        Arrays.sort(array);
        String key = new String(array);
        List<String> list = map.getOrDefault(key, new ArrayList<String>());
        list.add(str);
        map.put(key, list);
    }
    return new ArrayList<List<String>>(map.values());
}
```

#### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)



## Tree

#### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

递归

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    inorder(root, res);
    return res;
}

public void inorder(TreeNode root, List<Integer> res) {
    if (root == null) {
        return;
    }
    inorder(root.left, res);
    res.add(root.val);
    inorder(root.right, res);
}
```

非递归

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<>();
    Deque<TreeNode> stk = new LinkedList<TreeNode>();
    while (root != null || !stk.isEmpty()) {
        while (root != null) {
            stk.push(root);
            root = root.left;
        }
        root = stk.pop();
        list.add(root.val);
        root = root.right;
    }
    return list;
}
```

#### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

递归

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<>();
    preorderTraversalInternal(root, list);
    return list;
}

private void preorderTraversalInternal(TreeNode root, List<Integer> list) {
    if (root == null) {
        return;
    }
    list.add(root.val);
    preorderTraversalInternal(root.left, list);
    preorderTraversalInternal(root.right, list);
}
```

非递归

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<>();
    if (root != null) {
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            list.add(node.val);
            if (node.right != null) {
                stack.push(node.right);
            }
            if (node.left != null) {
                stack.push(node.left);
            }
        }
    }
    return list;
}
```

#### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

递归

```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<>();
    postorderTraversalInteral(root, list);
    return list;
}

public void postorderTraversalInteral(TreeNode root, List<Integer> list) {
    if (root == null) {
        return;
    }
    postorderTraversalInteral(root.left, list);
    postorderTraversalInteral(root.right, list);
    list.add(root.val);
}
```

非递归

#### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> lists = new ArrayList<>();
    if (root == null) {
        return lists;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        List<Integer> list = new ArrayList<>();
        int size = queue.size();
        for (int i = 0; i < size; i++) {
            TreeNode treeNode = queue.poll();
            list.add(treeNode.val);
            if (treeNode.left != null) queue.offer(treeNode.left);
            if (treeNode.right != null) queue.offer(treeNode.right);
        }
        lists.add(list);
    }
    return lists;
}
```

#### [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```java
public boolean isValidBST(TreeNode root) {
    return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);
}
private boolean isValidBST(TreeNode root, long lower, long upper) {
    if (root == null) {
        return true;
    }
    if (root.val <= lower || root.val >= upper) {
        return false;
    }
    return isValidBST(root.left, lower, root.val) && isValidBST(root.right, root.val, upper);
}
```

#### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

递归

```java
public TreeNode invertTree(TreeNode root) {
    if (root == null)  return root;
    TreeNode left = root.left;
    TreeNode right = root.right;
    root.right = left;
    root.left = right;
    invertTree(left);
    invertTree(right);
    return root;
}
```

非递归

```java
public TreeNode invertTree1(TreeNode root) {
    if (root == null)  return null;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        TreeNode left = node.left;
        TreeNode right = node.right;
        node.left = right;
        node.right = left;
        if (left != null) {
            queue.add(left);
        }
        if (right != null) {
            queue.add(right);
        }
    }
    return root;
}
```

#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

```java
public int maxDepth(TreeNode root) {
    if (root == null ) {
        return 0;
    }
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
```

#### [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

递归

第一种递归确实没想到，膜拜下国际站大佬:triangular_flag_on_post:

```java
public int minDepth(TreeNode root) {
    if (root == null) return 0;
    int left = minDepth(root.left);
    int right = minDepth(root.right);
    return (left == 0 || right == 0) ? left + right + 1 : Math.min(left, right) + 1;
}
```

```java
public int minDepth(TreeNode root) {
    if (root == null) return 0;
    if (root.left == null && root.right == null) return  1;
    int minDepth = Integer.MAX_VALUE;
    if (root.left != null) {
        minDepth = Math.min(minDepth(root.left), minDepth);
    }
    if (root.right != null) {
        minDepth = Math.min(minDepth(root.right), minDepth);
    }
    return minDepth + 1;
}
```

非递归

```java
class QueueNode {
    int depth;
    TreeNode node;
    public QueueNode(TreeNode node, int depth) {
        this.node = node;
        this.depth = depth;
    }
}
public int minDepth(TreeNode root) {
    if (root == null) return 0;
    Queue<QueueNode> queue = new LinkedList<>();
    queue.offer(new QueueNode(root, 1));
    while (!queue.isEmpty()) {
        QueueNode nodeDepth = queue.poll();
        TreeNode node = nodeDepth.node;
        int depth = nodeDepth.depth;
        if (node.left == null && node.right == null) return depth;
        if (root.left != null) {
            queue.offer(new QueueNode(root.left, depth + 1));
        }
        if (root.right != null) {
            queue.offer(new QueueNode(root.right, depth + 1));
        }
    }
    return 0;
}
```

#### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q) return root;
    TreeNode left = lowest(root.left, p, q);
    TreeNode right = lowest(root.right, p, q);
    return left == null ? right : right == null ? left : root;
}
```

#### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/):flags:



## 递归

#### [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

* 时间复杂度：2^2

```java
public List<String> generateParenthesis(int n) {
    List<String> result = new ArrayList<>();
    _generate(0, 0,n, "", result);
    return result;
}

private void _generate(int left, int right, int n, String s, List<String> result) {
    if (left == n && right == n) {
        result.add(s);
        return;
    }
    if (left < n) _generate(left + 1, right, n, s + "(", result);
    if (left > right) _generate(left, right + 1, n, s + ")", result);
}
```

#### [77. 组合](https://leetcode-cn.com/problems/combinations/):flags:

```java
public List<List<Integer>> combine(int n, int k) {
    List<List<Integer>> res = new ArrayList<>();
    if (k <= 0 || n < k) {
        return res;
    }
    Deque<Integer> path = new ArrayDeque<>();
    dfsHelper(n, k, 1, path, res);
    return res;
}

private void dfsHelper(int n, int k, int index, Deque<Integer> path, List<List<Integer>> res) {
    if (path.size() == k) {
        res.add(new ArrayList<>(path));
        return;
    }
    for (int i = index; i <= n; i++) {
        path.addLast(i);
        dfsHelper(n, k, i + 1, path, res);
        path.removeLast();
    }
}
```



#### [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/):flags:

#### [50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)

```java
public double Pow(double x, int n) {
    long N = n;
    if (N < 0) {
        N = -N;
        x = 1 / x;
    }
    return helper(x, n);
}

private double helper(double x, int n) {
    if (n == 0) {
        return 1;
    }
    double half = help(x, n / 2);
    return n % 2 == 1 ? half * half * x : half * half;
}
```

#### [78. 子集](https://leetcode-cn.com/problems/subsets/)

递归

> **注意：hepper() 方法的最后一行，恢复递归当前层的状态**，或者传递的时候传递新创建的集合

```java
public List<List<Integer>> subsets(int[] nums) {
    List<List<Integer>> res = new ArrayList<>();
    helper(res, new ArrayList<Integer>(), nums, 0);
    return res;
}

private void helper(List<List<Integer>> res, List<Integer> list, int[] nums, int index) {
    if (index == nums.length) {
        res.add(new ArrayList(list));
        return;
    }
    helper(res, list, nums, index + 1);
    list.add(nums[index]);
    helper(res, list, nums, index + 1);
    
    list.remove(list.size() - 1);
}

// ******************************************
public List<List<Integer>> subsets(int[] nums) {
    List<List<Integer>> res = new ArrayList<>();
    helper(res, new ArrayList<Integer>(), nums, 0);
    return res;
}

private void helper(List<List<Integer>> res, List<Integer> list, int[] nums, int index) {
    if (index == nums.length) {
        res.add(new ArrayList(list));
        return;
    }
    helper(res, new ArrayList(list), nums, index + 1);
    list.add(nums[index]);
    helper(res, new ArrayList(list), nums, index + 1);
}
```

枚举

```java
public List<List<Integer>> emumerate(int[] nums) {
    List<List<Integer>> res = new ArrayList<>();
    res.add(new ArrayList<Integer>());
    for (int num : nums) {
        int size = res.size();
        for (int i = 0; i < size; i++) {
            List<Integer> newSub = new ArrayList<>(res.get(i));
            newSub.add(num);
            res.add(newSub);
        }
    }
    return res;
}
```

## 分治&回溯

#### [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

分治

* 时间复杂度：O(nlogn)
* 空间复杂度：O(logn)

```java
public int majorityElement2(int[] nums) {
    return majorityElementHelper(nums, 0, nums.length - 1);
}

private int majorityElementHelper(int[] nums, int lo, int hi) {
    if (lo == hi) return nums[lo];
    int mid = (hi - lo) / 2 + lo;
    int left = majorityElementHelper(nums, lo, mid);
    int right = majorityElementHelper(nums, mid + 1, hi);
    if (left == right) return left;
    int leftCount = numCount(nums, left);
    int rightCount = numCount(nums, right);
    return leftCount > rightCount ? left : right;
}
private int numCount(int[] nums, int n) {
    int count = 0;
    for (int num : nums)
        if (num == n) count ++;
    return count;
}
```

Boyer-Moore 投票算法

* 时间复杂度：O(n)
* 空间复杂度：O(1)

```java
public int majorityElement(int[] nums) {
    int count  = 0;
    int candidate = nums[0];
    for (int num : nums) {
        if (count == 0) candidate = num;
        count += (num == candidate) ? 1 : -1;
    }
    return candidate;
}
```





