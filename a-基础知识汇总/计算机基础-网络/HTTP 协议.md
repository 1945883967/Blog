# HTTP 协议

## HTTP  协议相关概念

**HTTP 协议(HyperText Transfer Protocol)**：一种无状态的、应用层的、以请求/应答方式运行的协议，它使用可扩展的语义和自描述消息格式，与基于网络的超文本信息系统灵活的互动。

> RFC7230
>  The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  

超文本传输协议，从名字可以看出，它由 超文本、传输、协议三部分组成。

* 协议：HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。

* 传输：HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。

  > 1、HTTP协议是一个“双向协议”
  >
  > 2、不限定两个角色，允许有中转或接力A<=>X<=>Y<=>Z<=>B

* 超文本：就是“超越了普通文本的文本”，它是文字、图片、音频和视频等的混合体，最关键的是含有“超链接”，能够从一个“超文本”跳跃到另一个“超文本”，形成复杂的非线性、网状的结构关系。

  > 所谓“文本”（Text），就表示 HTTP 传输的不是 TCP/UDP 这些底层协议里被切分的杂乱无章的二进制包（datagram），而是完整的、有意义的数据，可以被浏览器、服务器这样的上层应用程序处理。

> Web's major goal was to be a shared information space through which people and machines could communicate.		-- Berners-Lee

**HTTP 解决了什么问题？**

* 低门槛
* 可扩展性：巨大的用户群体，超长的寿命
* 分布式系统下的 Hypermedia：处理大数据的网络传输
* Internet 规模
  * 无法控制的 scalability
  * 

**HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。**

**URI/URL**：

URI（Uniform Resource Identifier），中文名称是 统一资源标识符，使用它就能够唯一地标记互联网上资源。

URI的基本组成部分：协议名，主机名，路径。

> http://   nginx.org   /en/download.html
>
> 协议名  主机名         路径

URI 另一个更常用的表现形式是 URL（Uniform Resource Locator）， 统一资源定位符，也就是我们俗称的“网址”，它实际上是 URI 的一个子集，差异不大，所以通常不会做严格的区分。

## HTTP 协议格式

HTTP的核心是：它传输的报文内容

### 报文结构

TCP 报文有 20 字节的头部数据，存储 TCP 协议必须的额外信息，例如发送方的端口、接受方的端口、包序号、标志位等等

![img](https://static001.geekbang.org/resource/image/17/95/174bb72bad50127ac84427a72327f095.png)



HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：

1. 起始行（start line）：描述请求或响应的基本信息；
2. 头部字段集合（header）：使用 key-value 形式更详细地说明报文；
3. 消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。

这其中起始行和头部字段经常又称为 **请求头** 或 **响应头**，消息正文又称为**实体**(很多时候直接称为 **body**)

HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。一个完整的 HTTP 报文如下图所示：

![img](https://static001.geekbang.org/resource/image/62/3c/62e061618977565c22c2cf09930e1d3c.png)

### 起始行

#### 请求行

**请求行(request line)**：简要地描述了客户端想要如何操作服务器端的资源。

请求行由三部分构成：

1. 请求方法：是一个动词，如 GET/POST，表示对资源的操作；
2. 请求目标：通常是一个 URI，标记了请求方法要操作的资源；
3. 版本号：表示报文使用的 HTTP 协议版本。

这三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束。

![img](https://static001.geekbang.org/resource/image/36/b9/36108959084392065f36dff3e12967b9.png)

Wireshark 抓包的请求行为

```
GET / HTTP/1.1
```

> “GET”是请求方法，“/”是请求目标，“HTTP/1.1”是版本号

#### 状态行

**状态行(status line)**：意思是服务器响应的状态。

> 响应报文里的起始行。

也由三部分组成

1. 版本号：表示报文使用的 HTTP 协议版本，通常是 HTTP/1.1
2. 状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；
3. 原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。

![img](https://static001.geekbang.org/resource/image/a1/00/a1477b903cd4d5a69686683c0dbc3300.png)

Wireshark 抓包案例：

```
HTTP/1.1 200 OK
```

### 头部字段

请求行或状态行再加上头部字段集合就构成了 HTTP 报文里完整的请求头或响应头。

头部字段是 key-value 的形式，key 和 value 之间用“:”分隔，最后用 CRLF 换行表示字段结束。

HTTP 头字段非常灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头。

> **注意**：
>
> 1. 字段名不区分大小写
> 2. 字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。
> 3. 字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；
> 4. 字段的顺序是没有意义的，可以任意排列不影响语义；
> 5. 字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。

**请求头字段**

HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：

1. 通用字段：在请求头和响应头里都可以出现；
2. 请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；
3. 响应字段：仅能出现在响应头里，补充说明响应报文的信息；
4. 实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。

### 请求方法

HTTP 的报文结构，由 header + body 构成，请求头里有请求方法和请求目标，响应头里有状态码和原因短语。

**标准请求方法**

目前 HTTP/1.1 规定了八种方法，单词都必须是大写的形式

* GET：获取资源，可以理解为读取或者下载数据；
* HEAD：获取资源的元信息；HEAD 只传回响应头，即获取资源元信息。
* POST：向资源提交数据，相当于写入或上传数据；通常 POST 表示的是“新建”“create”的含义
* PUT：类似 POST；通常 PUT 则是“修改”“update”的含义
* DELETE：删除资源；
* CONNECT：建立特殊的连接隧道；
* OPTIONS：列出可对资源实行的方法；要求服务器列出可对资源实行的操作方法，在响应头的 Allow 字段里返回
* TRACE：追踪请求 - 响应的传输路径。

![img](https://static001.geekbang.org/resource/image/3c/6d/3cdc8ac71b80929f4a94dfeb9ffe4b6d.jpg)

这些操作类似与数据库的“增删改查”，只不过操作的目标不是本地资源，而是远程服务器上的资源。

> 增：POST;； 删：DELETE ； 改：PUT； 查：GET

**安全**：是指请求的方法不会“破坏”服务器上的资源，即不会对服务器上的资源造成实质的修改。

> 只有 GET 和 HEAD 方法是 “安全“的，因为他们是 ”只读“操作，只要服务器不故意曲解请求方法的处理方式，无论 GET 和 HEAD 操作多少次，服务器上的数据都是“安全的”。
>
> 而 POST/PUT/DELETE 操作会修改服务器上的资源，增加或删除数据，所以是“不安全”的。

**幂等**：多次执行相同的操作，结果都是相同的，即多次”幂“后结果”相等“

> GET 和 HEAD 既是安全的也是幂等的，DELETE 可以多次删除同一个资源，效果都是“资源不存在”，所以也是幂等的。
>
> 按照 RFC 里的语义，POST 是“新增或提交数据”，多次提交数据会创建多个资源，所以不是幂等的；而 PUT 是“替换或更新数据”，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的。

### 响应状态码

状态码是一个十进制数字，代表服务器对请求的处理结果。

> “状态码”而不是“错误码”。也就是说，它的含义不仅是错误，更重要的意义在于表达 HTTP 数据处理的“状态

目前 RFC 标准里规定的状态码是三位数，所以取值范围就是从 000 到 999。目前 RFC 标准里总共有 41 个状态码，但状态码的定义是开放的，允许自行扩展。

RFC 标准把状态码分成了五类，用数字的第一位表示分类，而 0~99 不用，这样状态码的实际可用范围就大大缩小了，由 000~999 变成了 100~599。

这五类的具体含义是：

* 1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；

  > 常见的有 101 Switching Protocols，

* 2××：成功，报文已经收到并被正确处理；

  > “200 OK”是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果
  >
  > “204 No Content” 含义与“200 OK”基本相同，但响应头后没有 body 数据。
  >
  > 206 Partial Content”是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。状态码 206 通常还会伴随着头字段“Content-Range”，表示响应报文里 body 数据的具体范围，供客户端确认，例如“Content-Range: bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。

* 3××：重定向，资源位置发生变动，需要客户端重新发送请求；

  > “301 Moved Permanently”俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用新的 URI 再次访问。
  >
  > “302 Found” 俗称“临时重定向”（Moved Temporarily）
  >
  > “304 Not Modified” 用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。

* 4××：客户端错误，请求报文有误，服务器无法处理；

  > “400 Bad Request”
  >
  > “403 Forbidden”
  >
  > “404 Not Found”
  >
  > 405 Method Not Allowed
  >
  > 406 Not Acceptable
  >
  > 413 Request Entity Too Large
  >
  > 414 Request-URI Too Long
  >
  > 429 Too Many Requests
  >
  > 431 Request Header Fields Too Large

* 5××：服务器错误，服务器在处理请求时内部发生了错误。

  > 500 Internal Server Error
  >
  > 501 Not Implemented
  >
  > 502 Bad Gateway
  >
  > 503 Service Unavailable

### 其他相关概念

URI，也就是统一资源标识符（Uniform Resource Identifier），URI 是用来唯一标记服务器上资源的一个字符串，通常也称为 URL；

URI包含 URL 和 URN两部分，在HTTP世界里的网址实际上是 URL 统一资源定位符（Uniform Resource Locator）

URI 的格式：由 scheme、host:port、path 和 query 四个部分组成，但有的部分可以视情况省略。

![img](https://static001.geekbang.org/resource/image/46/2a/46581d7e1058558d8e12c1bf37d30d2a.png)

* **scheme（方案名或协议名）**：表示资源应该使用哪种协议来访问。

* **://**：scheme 之后，必须的三个特定的字符，它把 scheme 和后面的部分分离开

* **authority**：表示资源所在的主机名，通常的形式是 host:post，即主机名加端口号。端口号有时可以省略，浏览器等客户端会依据 scheme 使用默认的端口号，例如 HTTP 的默认端口号是 80，HTTPS 的默认端口号是 443。

* **path**：标记资源所在位置的 Path，URI 的 path 部分必须以“/”开始，也就是必须包含“/”，

* **query**:表示对资源附加的额外要求；在 path 之后，用一个“?”开始，但不包含“?”，表示对资源附加的额外要求。查询参数 query 有一套自己的格式，是多个“key=value”的字符串，这些 KV 值用字符“&”连接，浏览器和服务器都可以按照这个格式把长串的查询参数解析成可理解的字典或关联数组形式。

URI 的完整格式

![img](https://static001.geekbang.org/resource/image/ff/38/ff41d020c7a27d1e8191057f0e658b38.png)

协议名之后、主机名之前的身份信息“user:passwd@”，表示登录主机时的用户名和密码，但现在已经不推荐使用这种形式了（RFC7230）

查询参数后的片段标识符“#fragment”，它是 URI 所定位的资源内部的一个“锚点”或者说是“标签”，浏览器可以在获取资源后直接跳转到它指示的位置。

URI 里只能使用 ASCII 码，当有汉语、@&/”等特殊字符时，将进行编码，否则服务器收到 HTTP 报文后会无法正确处理。编码直接把非 ASCII 码或特殊字符转换成十六进制字节值，然后前面再加上一个“%”。

## HTTP 优缺点



# DNS 协议

DNS  协议可能会经历从操作系统、本地 DNS、根DNS、顶级 DNS、权威 DNS 的层层解析的过程。为避免每次都经历这个复杂繁琐的过程，这中间会存在DNS缓存。



