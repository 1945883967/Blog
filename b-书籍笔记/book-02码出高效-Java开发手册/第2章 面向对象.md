# 第二章 面向对象

oop的的三大特征：封装、继承、多态。（抽象）

oops实现了软件工程的三个主要目标：可维护性、可重用性和可扩展性。

## 2.1 OOP理念

面向过程的结构相对松散，强调如何流程化地解决问题；

面向对象的的思维更加内聚，强调高内聚、低耦合，先抽象模型，定义共性行为，在解决问题。

面向对象三大基本特征：**封装、继承、多态**（抽象）

* 封装：是一种对象功能内聚的表现形式，使模块之间耦合度变低，更具有维护性。
* 继承：使子类能够继承父类，获得父类的部分属性和行为，使模块更有复用性。
* 多态：使模块在复用性基础上更具有扩展性，使运行期更有想象空间。

clone()的浅拷贝、一般深拷贝和彻底深拷贝

* 浅拷贝：只复制当前对象的所有基本数据类型，以及相应的引用变量，但没有复制引用指向的实际对象；

* 彻底深拷贝：在成功clone一个对象之后，此对象与母对象在任何引用路径上都不存在共享的实例对象。

* 一般深拷贝：介于浅拷贝和彻底深拷贝之间；

  Object的clone()方法默认是浅拷贝。

迪米特法则（设计模式七大原则之一，是对于封装的具体要求）：A模块使用B模块的某个接口行为，对B模块中除此方法之外的其信息知道的尽可能少。

里氏代换原则（LSP）:指任何父类能够出现的地方，子类都能够出现。

* 在显示==现实代码环境中，如果父类引用直接使用子类引用来代替，可以编译正确并执行，输出结果符合类场景的预期，那么说明两个类之间符合LSP原则，可以使用继承关系。

谨慎使用继承，避免方法污染和方法爆炸，提倡组合优先原则来扩展类的能力。

多态：运行时实际对象类型，同一个方法产生不同的运行结果，使的一个行为具有不同的表现形式。

容易混淆的两个概念**”override“和“overload”**

* **override**:译成“覆写”，是子类实现接口，或者继承父类时，保持方法签名完全相同，实现不同的方法体，是垂直方向上行为的不同实现。
* **overload**： 译成“重载”，方法名称是相同的，但是参数类型或参数个数是不相同的，是水平方向上行为的不同实现。

多态是指在变异层面无法确定最终的方法体，以覆写为基础来实现面向对象的特性，在运行期由JVM进行动态绑定，调用合适的覆写方法体来执行。重载是编译期确定方法调用，属于静态绑定，本质上重装的结果是完全不同的方法，所以**多态专指覆写**。

## 2.2 初始Java

JDK(Java Develipment Kit):Java开发工具包

JRE(Java Runtime Enviroment):Java运行环境，包括JVM、核心类库、核心配置工具等。

JVM(Java Virtula Machine):java虚拟机，它是整个Java技术体系的底层支撑平台，把源文件翻译成平台无关的字节码文件。

 Java语言主要特点：跨平台、分布式、多线程、健壮性。

## 2.3 类

### 2.3.1 类的定义

类：由访问级别、类型、类名、是否抽象、是否静态、泛型标识、继承或实现关键字、父类或接口名称等组成。

* 类的访问级别：public和无访问控制符
* 类型：class, interface, enum

java类主要由两部分组成：成员和方法。

定义类时类中定义各个部分的顺序：变量-->共有方法-->私有方法-->getter/setter方法

### 2.3.2 接口与抽象类

接口和抽象类的共同点是都不能被实例化，但可以定义引用变量指向实例对象。

两者的不同：

* 语法区别
  ![Snipaste_2019-04-18_09-37-29.jpg](https://i.loli.net/2019/04/18/5cb7d4f93f9ef.jpg)

 抽象类在被继承时体现的是is-a关系，接口在被实现时体现的是can-do关系。

* is-a关系需要符合里氏代换原则，例如：Eagle is a Bird. Bird is an Object.

* can-do关系要符合接口隔离原则，实现类要又能力去实现接口中定义的行为，例如：Plane can fly. Bird can fly.中应给把fly定义成一个接口，而不是把fly()放在某个抽象类中，在由Plane和Bird利用is-a关系去继承此抽象类。

抽象类是模版式设计，而接口是契约式设计。

接口是顶级的“类”，虽然关键字是interface，但是编译后的字节码扩展名还是.clss；抽象类是二当家，接口位于顶层，而抽象类对接口进行了组合，然后实现部分接口行为。

接口继承接口，关键字是extends，允许多继承，某个实体类实现多重继承后的接口时，只能说明“can do many things"。

### 2.3.3 内部类

在一个.java文件中，只能定义一个类名与文件名完全一致的公开类，使用public class 关键字来修饰。

内部类就是一个属性，与其他属性定义方式一致。比如：属性字段private static String str,由访问控制符、是否静态、类型、变量名组成，而内部类private static class Inner{},也是按这样的顺序来定义的，类型可以为class,enum,(甚至是interface,但内部类中定义接口是不推荐的)，甚至可以一匿名的方式出现，具体分为如下四种：

* 静态内部类，如：static class StaticInnerClass{}

* 成员内部类，如：private class InstanceInnerClass{}

* 局部内部类，定义在方法或者表达式内部。

* 匿名内部类，如：(new Thread(){}).start()。

  四种内部类的定义方式：

  ```java
  public class OuterClass {
  	//成员内部类
  	private class InstanceInnerClass{}
  	
  	//静态内部类
  	static class StaticInnerClass{}
  	
  	public static void main(String[] args) {
  		//两个匿名内部类
  		(new Thread() {}).start();
  		(new Thread() {}).start();
  		
  		//两个方法内部类
  		class MehtodClass1{}
  		class MehtodClass2{}
  	}
  }
  ```
  对应的生成的.class文件目录

  ![Snipaste_2019-04-18_11-39-51.jpg](https://i.loli.net/2019/04/18/5cb7f1b788c8a.jpg)

  外部类与内部类之间使用$符号分隔，匿名内部类使用数字进行编号，而方法内部类，在类名前还有一个编号来标识是那个方法。

  **静态内部类**：是最常用的内部表现形式，外部可以使用OuterClass.StaticInnerClass直接访问，类加载与外部类在同一阶段，在JDK源码中，定义包内可见静态内部类的方式很常见，这样做的好处是：

  * 作用域不会扩散到包外
  * 可以通过”外部类.内部类“的方式直接访问。
  * 内部类可以访问外部类中所有静态属性和方法。

  内部类中还可以定义内部类，形成多层嵌套。

  ### 2.3.4 访问控制权限

  


