# 第21章 并发

## 2.基本的线程机制

并发编程使得我们可以将程序划分为多个分离的、独立运行的任务。通过多线程机制，这些子任务中的每一个都由执行线程来驱动。多线程的底层机制是切分CPU时间。

### 2.1定义任务

线程可以驱动任务，因此需要一种描述任务的方式，可以通过Runnable接口来提供。通过实现Runnable接口并编写run()方法，使得任务可以执行你的命令。

```java
public class LiftOff implements Runnable {
  protected int countDown = 10; // Default
  private static int taskCount = 0;
  private final int id = taskCount++;
  public LiftOff() {}
  public LiftOff(int countDown) {
    this.countDown = countDown;
  }
  public String status() {
    return "#" + id + "(" +
      (countDown > 0 ? countDown : "Liftoff!") + "), ";
  }
  public void run() {
    while(countDown-- > 0) {
      System.out.print(status());
      Thread.yield();
    }
  }
  public static void main(String[] args) {
	  LiftOff lauch = new LiftOff();
	  lauch.run();
  }
} /*Output:
#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!), 
*/
```

### 2.3Thread类

将Runnable对象转变为工作任务的传统方式是把它提交给一个Thread构造器。通过Thread对象的start()方法为该线程执行必须的初始化操作，人后调用Runnable的run()方法，在这个新线程中启动任务。

## 2.4 使用Executor



## 2.8 后代线程

后台（daemon)线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的一部分。因此所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。

在线程被启动之前，即调用Thread的start()方法之前，调用Thread的方法`setDaemon(true)`方法，即可将线程设为后台线程(但在没有非后台线程运行的情况下，后台线程会突然终止）。