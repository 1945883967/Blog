# 类型信息

运行时类型信息可以使你在程序运行时发现和使用类型信息。

java中识别类型信息的方式有两种方式：

- “传统的”RTTI(Run-Time Type Identification)，它假定我们在编译时已经知道了所有的类型信息；在运行时，识别一个对象的类型。
- “反射”机制，它允许我们在运行程序时发现和使用类的信息。

如果某个对象出现在字符串表达式中(涉及“+”和字符串对象的表达式)，toString()方法会被自动调用，以生成表示该对象的String。

### Class对象

类是程序的一部分，每一个类都有一个Class对象(每当编写并编译了一个新类，就会产生一个Class对象，(被保存在一个同名的.class文件中))

**类加载子系统**：即一条类加载链，但是只有一个原生的***原生类加载器***，它是JVM实现的一部分。原生类加载器加载的是原生类，包括Java API类，它们通常是从本地磁盘加载的。 如果有特殊需求，可以挂接额外的类加载器。

所有的类都在第一次使用时，动态加载到`JVM`中的。当程序创建第一个类的静态成员的引用时，就会加载这个类。`这证明构造方法也是类的静态方法，即使构造器之前并没有使用static关键字，`因此，使用new操作符创建类的新对象也会被当做类的静态成员的引用。因此，java程序在它开始运行之前并非被完全加载，各个部分是在必须时才加载的。**动态加载**

类加载器首先检查这个类的Class对象是否已经加载。如果尚未加载，默认的类加载器就会根据类名查找.class文件。在这个类的字节码被加载时，它们会接受验证，以确保其没有被破坏，并且不包含不良Java代码(这是java中用于安全防范目的的措施之一)。

`一旦某个类的Class对象被载入内存，它就被用来创建这个的所有对象`

Class对象仅在需要的时候才会被加载，static初始化是在类加载时进行的。

### 类字面常量

用类字面长量(Person.class)来生成对Class对象的引用，不仅简单，而且更安全，因为它在编译时就会受到检查(因此不需要置于try语句块中)。并且他根除了对forName()方法的调用，多以也更高效。

类字面常量不仅可以用于普通类，也可用于接口、数组以及基本数组类型。另外对于基本类型的包装类，还有一个标准字段TYPE。TYPE 字段是一个引用，指向对应的基本数据类型的Class对象，boolean的包装类型下的TYPE：

` Class<Boolean> TYPE = (Class<Boolean>) Class.getPrimitiveClass("boolean");`

`boolean.class 等价于  Boolean.TYPE`

其他基本类型(及包装类型)也是如此。

建议使用”.class“的形式，以保持与普通类型的一致性。

注意：当使用“.class"来创建对Class对象的引用时，不会自动地初始化该Class对象。为旅客使用类而做的工作实际包含三部分：

- 加载：由类加载器加载，该步骤查找字节码，并从这些字节码中创建一个Class对象。
- 链接：将验证类中的字节码，为静态域分配空间，并且如果有需要的话，将解析这个类创建的对其他类的所有引用。
- 初始化：如果该类具有超类，则对其初始化，执行静态初始化和静态初始化块。初始化被延迟到了静态方法(构造器隐式地静态的)或者非常数静态域进行首次引用时才执行。

.class形式的产生Class引用不会引发初始化，初始化有效的实现了尽可能的“惰性”。但是，为了产生Class引用，Class.forName()立即就进行了初始化。

如果一个`static final值是编译器常量`,那么这个值不需要对类初始化就可以被读取。

如果一个域设置为static和final的，还不足以确保种行为。(即对static final的值要附具体的值，如static final int temp = 10;)

**泛化的Class引用**

javaSE5中，Class<?>优于平凡的Class，即便他们是等价的。Class<?>的好处是它表示你并非是碰巧或者由于疏忽，而使用了一个非具体的类引用，选择了非具体的版本。

为了创建一个Class引用，它被限定为某种类型，或该类型的任何子类型，需要将通配符与extends关键字相结合，创建一个范围。`Class<? extends Number>`。向Class引用添加泛型语法的原因仅仅是为了提供编译器类型检查，如果操作有误，在编译期就可以检查出来，避免在运行时出错。

### 类型转换前先做检查

RTTI在java中还有第三种形式，就是关键字instanceof。它返回一个布尔值，告诉我们**对象是不是某个特定对象的实例**。

Class.isInstance方法提供了一种动态的测试对象的途径。instanceof语句都可以用Class的对象.isInstance()方法代替。

### 使用反射而不适用new关键字创建对象的优点

**反射可以不用类名实例化对象，并且降低耦合，避免了硬编码。**

注：Java里面，反射的目的**高内聚，低耦合**

### 接口与类型信息

**interface**关键字的一种重要目标就是允许程序员隔离构建，进而降低耦合性。

