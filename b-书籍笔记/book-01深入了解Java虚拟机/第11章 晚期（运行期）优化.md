# 第11章 晚期（运行期）优化

##  1.概述

在部分的商用虚拟机（Sun HotSpot、IBM J9）中，Java程序最初是通过解释器 （Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”（Hot Spot Code）。为了提高热点代码的执行效率，在运行时， 虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler，简称JIT编译器）。 

## 2.HotSpot虚拟机内的即时编译器

### 2.1 解释器与编译器

解释器与编译器两者各有优势：**当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。 在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。**当程序运行环境中内存资源限制较大（如部分嵌入式系统 中），可以使用解释执行节约内存，反之可以使用编译执行来提升效率。同时，解释器还可 以作为编译器激进优化时的一个“逃生门”，让编译器根据概率选择一些大多数时候都能提升 运行速度的优化手段，当激进优化的假设不成立，如加载了新类后类型继承结构出现变化、 出现“罕见陷阱”（Uncommon Trap）时可以通过逆优化（Deoptimization）退回到解释状态继 续执行（部分没有解释器的虚拟机中也会采用不进行激进优化的C1编译器担任“逃生门”的角色），因此，在整个虚拟机执行架构中，解释器与编译器经常配合工作，如图所示

![Snipaste_2019-08-13_15-56-57.jpg](https://i.loli.net/2019/08/13/tHFvcAEhNBnPgUW.jpg)
HotSpot虚拟机中内置了两个即时编译器，分别称为Client Compiler和Server Compiler， 或者简称为**C1编译器和C2编译器（**也叫Opto编译器）。目前主流的HotSpot虚拟机中，默认采用解释器与其中一个编译器直接配合的方式工 作，程序使用哪个编译器，取决于虚拟机运行的模式，HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用“-client”或“-server”参数去强制指定虚 拟机运行在Client模式或Server模式。 

无论采用的是C1还是C2，**解释器与编译器搭配使用的方式在虚拟机中称为“混合模式”(Mixed Mode)**，用户可以使用参数“-Xint"强制虚拟机运行于”**解释模式**“(Interpreted Mode)，这时编译器不介入工作，全部代码都使用解释方法执行。另外，也可以使用参数”-Xcomp"强制虚拟机运行于“**编译模式**”（Compiled Model),这时将优先采用编译方式执行程序，但是解释器任然要在编译无法进行的情况下介入执行过程。

`java -verbose`可以查看这三种模式

由于即时编译器编译本地代码需要占用程序运行时间，要编译出优化程度更高的代码， 所花费的时间可能更长；而且想要编译出优化程度更高的代码，解释器可能还要替编译器收 集性能监控信息，这对解释执行的速度也有影响。为了在程序启动响应速度与运行效率之间 达到最佳平衡，HotSpot虚拟机还会逐渐启用分层编译的策略。分层编译根据编译器编译、优化的规模与耗时，划分出不同 的编译层次，其中包括： 

* 第0层，程序解释执行，解释器不开启性能监控功能（Profiling），可触发第1层编译。 
* 第1层，也称为C1编译，将字节码编译为本地代码，进行简单、可靠的优化，如有必要 将加入性能监控的逻辑。 
* 第2层（或2层以上），也称为C2编译，也是将字节码编译为本地代码，但是会启用一些 编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。 

实施分层编译后，Client Compiler和Server Compiler将会同时工作，许多代码都可能会被 多次编译，用Client Compiler获取更高的编译速度，用Server Compiler来获取更好的编译质 量，在解释执行的时候也无须再承担收集性能监控信息的任务。 

### 2.2 编译对象与触发条件

在运行过程中会被即时编译的“热点代码”有两类，即：

* **被多次调用的方法** （标准的JIT编译）
* **被多次执行的循环体**（编译依然会以整个方法作为编译对象），由于这种编译方式因为编译发生在方法执行过程中，因此形象地称为栈上替换(On Stack Replacement),简称为OSR编译，即方法还在栈上，方法就被替换了）。

**热点探测(Hot Spot Detection)**:判断一段代码是不是热点代码，是不是要触发即时编译。

目前主要的热点探测判定方式：

* **基于采样的热点探测**(Sample Based Hot Spot Detection):周期性地检查各个线程的栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”。基于采样的热点探测的好处是实现简单、高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可），缺点是很难精确地确认一个方法的热度，容易因为受到线 程阻塞或别的外界因素的影响而扰乱热点探测。 
* **基于计数器的探测**(Count Based Hot Spot Detection)：采用这种方法的虚拟机会 为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的 阈值就认为它是“热点方法”。统计结果相对精确。

在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，它为每个方法准备两个计数器：方法调用计数器和回边计数器。

方法调用计数器：这个计数器用于统计方法调用的次数，默认阈值在Client模式下是1500次，在Server模式下是10 000次，这个阈值可以通过 虚拟机参数-XX：CompileThreshold来人为设定。

回边计数器：统计一个方法中循环体代码执行的次数，在字节码中遇到控制流后向前跳转的指令称为“回边”(Bace Edge)。（显然，建立回边计数器统计的目的是为了触发OSR）

### 3. 编译过程

对于Client Compiler，是一个简单快速的三段编译器，主要的关注点在于局部性的优化，而放弃了许多耗时较长的全局优化手段。

![Snipaste_2019-08-13_20-08-47.jpg](https://i.loli.net/2019/08/13/nNKXDvwuGdia3eA.jpg)
对于Server Compiler则是专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译器，也是一个充分优化过的高级编译器，会执行所有经典的优化动作，还会实施一些与Java语言特性密切相关的优化技术，另外，还可能根据解释器或Client Compiler提供的性能监控信息，进行一些不稳定的激进优化。

### 4. 查看及分析即时编译结果

## 3.编译优化技术

以编译的方式执行本地代码比解释方式更快了，因为虚拟机解释执行字节码时额外消耗时间，另外，虚拟机设计团队几乎把对代码的所有优化措施都集中在了即时编译器之中。

**公共子表达式消除**

局部公共子表达式消除

全局公共子表达式消除

**数组边界检查消除**：是即时编译器中语言相关的一项的经典优化技术。

**方法内联**：消除方法调用的成本，为其他优化手段建立良好的基础。

**逃逸分析**

当一个对象在方法中被定义后，它可能 被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸。甚至还有可能被 外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。 

栈上分配

同步消除

标量替换

