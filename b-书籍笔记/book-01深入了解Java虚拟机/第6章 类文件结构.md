#  第六章 类文件结构



代码编译的结果从本地机器码转变为字节码（Java的.class文件）。

计算机只认识0和1，所以我们写的程序需要经编译器翻译成0和1构成的二进制格式才能由计算机执行。但随着技术的发展，越来越多的程序设计语言选择了与操作系统和机器指令集无关的、平台中立的格式作为编译后的存储格式。

## 6.2无关性的基石

各种**不同的虚拟机**与**所有平台**都统一使用的程序存储格式---**字节码**（ByteCode)是构成平台无关性的基石。

实现**语言无关性**基石仍然是**虚拟机和字节码存储格式**。**Java虚拟机不和包括Java在内的任何语言绑定**，它只与**“Class文件"**这种特定的二进制文件格式所关联，Class文件包含了Java虚拟机**指令集**和**符号表**以及若干其他辅助信息。基于安全方面的考虑，Java虚拟机规 范要求在Class文件中使用许多强制性的语法和结构化约束，但任何一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。

作为一个**通用的、机器无关**的**执行平台**， 任何其他语言的实现者都可以将Java虚拟机作为语言的产品交付媒介。例如，使用Java编译 器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他语言的编译器一样可以 把程序代码编译成Class文件，虚拟机并不关心Class的来源是何种语言，如图
![Snipaste_2019-04-02_11-47-53.jpg](https://i.loli.net/2019/04/02/5ca2db7e87ed4.jpg)

Java语言中的**各种变量、关键字和运算符号的语义**最终都是由**多条字节码命令组合而成**的，因此**字节码命令**所能提供的语义描述能力肯定会比Java语言本身更加强大。因此，**字节码本身**可以有效支持一 些Java语言本身无法有效支持的语言特性，这也为其他语言实现一些有别于Java的语言特性提供了基础。

**任何一个Class文件都对应着唯一一个类或接口的定义信息**，但反过来说，类或接 口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成）。

Class文件是一组以8位字节为基础单位的二进制流，各个数据项严格按照顺序紧凑的排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割若干个8位字节进行存储。

根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存 储数据，这种伪结构中只有两种数据类型：**无符号数和表**。

**无符号数**：属于基本的数据类型，以u1、u2、u4、u8分别来代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。

**表**：是由多个无符号数或者其他表作为数据项的复合数据数据类型，所有表都习惯性以**"_info"**结尾。表用于描述有层次关系的复合数据类型，整个Class文件本质上就是一张表，它由以下数据项构成。
![Snipaste_2019-04-02_12-19-41.jpg](https://i.loli.net/2019/04/02/5ca2e2e7d80b9.jpg)

## 6.3 Class类文件结构

任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接 口并不一定都得定义在文件里(譬如类或接口也可以通过类加载器直接生成)。

Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地 排列在Class文件之中，中间没有添加任何分隔符，整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。

当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前（**Big-Endian**）的方式分割成若干个8位字节进行存储。

注：Big-Endian ----具体是指最高位字节在地址最低位、最低位字节在地址最高 位的顺序来存储数据 。

Class文件中只有两种数据类型：**无符号数和表**。

**无符号数**：属于基本的数据类型，，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个 字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8 编码构成字符串值。 

**表**：由多个无符号数或者其他表作为数据项构成的复合数据类型，，所有表都习惯性地 以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张 表，它由下表数据项构成
![Snipaste_2019-04-03_20-04-15.jpg](https://i.loli.net/2019/04/03/5ca4a19acf942.jpg)

### 6.3.1 魔数与Class文件版本

**魔数（Magic Number）**：每个Class文件的头4个字节，用来确定这个文件是否为一个能被虚拟机接受的Class文件。（很多文件都用魔数来进行身份识别，使用魔数而不是扩展名来进行身份识别主要基于安全方面的考虑，因为文件扩展名可以随意改动。）

**版本号**：紧跟魔数第5和第6个字节是**次版本号（Minor Version）**，第7第8个字节是**主版本号（Major Version）**。Java的版本号从45开始，JDK 1.1之后的每个JDK大版本发布主版本号向上加1（JDK 1.0～1.1使用了45.0～45.3的 版本号），高版本的JDK能向前兼容以前版本的Class文件，但低版本的JDK不能向后兼容新版本的Class文件。

书中的Java代码示例(书中是以Java1.6编译的)：

```java
package org.fenixsoft.clazz;

public class TestClass {
	
	private int m;
	
	public int inc() {
		return m + 1;
	}
}
```

编译后的Java Class文件：
![Snipaste_2019-04-03_20-36-38.jpg](https://i.loli.net/2019/04/03/5ca4aa1837c8b.jpg)
从图中可以看到，前4个字节的十六进制表示是0xCAFEBABE,代表次版本号的第5个和第6个字节值为 0x0000，而主版本号的值为0x0032，也即是十进制的50，该版本号说明这个文件是可以被 JDK 1.6或以上版本虚拟机执行的Class文件。

:smirk:以下是jdk1.8下编译的Java Class文件
![Snipaste_2019-04-03_20-48-31.jpg](https://i.loli.net/2019/04/03/5ca4abaa93ef5.jpg)

### 6.3.2 常量池

主版本号之后是**常量池**入口，常量池可以理解为Class文件之中的资源仓库，它是Class文件之中与其他项目关联最多的数据类型，也是占用Class文件空间做大的数据项目之一，它也是Class文件中第一个出现的表数据类型项目。

常量池中存放量大类常量：**字面量（Literal）和符号引用（Symbolic Reference）**。

:triangular_flag_on_post:常量池中的每一项常量都是一个表，一共有14种常量类型，表都有一个共同的特点，就是表开始的第一位是一个u1类型的标志位（tag，取值 见表6-3中标志列），代表当前这个常量属于哪种常量类型。所代表的具体 含义见表
![Snipaste_2019-04-03_21-14-30.jpg](https://i.loli.net/2019/04/03/5ca4b1cc4d7f5.jpg)

这14种常量类型各自均有自己的结构，CONSTANT_Class_info的结构
![Snipaste_2019-04-03_21-18-56.jpg](https://i.loli.net/2019/04/03/5ca4b2c9711b4.jpg)

tag是标志位，它用于区分常量类型；name_index是一个索引值，它指 向常量池中一个CONSTANT_Utf8_info类型常量，此常量代表了这个类（或者接口）的全限 定名，这里name_index值（偏移地址：0x0000000B）为0x0002，也即是指向了常量池中的第 二项常量。。继续从图6-3中查找第二项常量，它的标志位（地址：0x0000000D）是0x01，查 表6-3可知确实是一个CONSTANT_Utf8_info类型的常量。CONSTANT_Utf8_info类型的结构见表6-5。
![Snipaste_2019-04-03_21-25-37.jpg](https://i.loli.net/2019/04/03/5ca4b45a1daa0.jpg)

length值说明了这个UTF-8编码的字符串长度是多少字节，它后面紧跟着的长度为length 字节的连续数据是一个使用UTF-8缩略编码表示的字符串。

由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来 描述名称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度。而这里的最大长度就是length的最大值，既u2类型能表达的最大值65535。所以Java程 序中如果定义了超过64KB英文字符的变量或方法名，将会无法编译。 

###  6.3.3访问标志
 :dart:常量池之后紧跟的两个字节代表**访问标志（access_flags）**,这个标志用于识别一些类或者接口层次的访问信息，包括：：这个Class是类还是接口；是否定义为public类 型；是否定义为abstract类型；如果是类的话，是否被声明为final等。具体的标志位以及标志 的含义见表
![Snipaste_2019-04-03_21-36-36.jpg](https://i.loli.net/2019/04/03/5ca4b6ed92981.jpg)

### 6.3.4 类索引、父类索引与接口索引集合

Class文件中由这三项来确定类的继承关系。

**类索引 （this_class）**：是一个u2类型的数据，用于确定这个类的全限定名。

**父索引（super_class）**：是一个u2类型的数据，用于确定这个类的父类的全限定名。Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java 类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。

**接口索引（interfaces）**：是一组u2类型的数据**集合**，用来描述这个类所实现的接口。被实现的接口将按implements语句（如果这个类本身 是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。 

类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用 两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常 量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在 CONSTANT_Utf8_info类型的常量中的全限定名字符串。

对于接口索引集合，入口的第一项——u2类型的数据为接口计数器 （interfaces_count），表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0， 后面接口的索引表不再占用任何字节。

### 6.3.5 字段表集合

**字段表（field_info）**用于描述**接口或者类中声明的变量**。字段（field）包括类级变量以及实例级变量（是否是static关键字修饰的变量9），但**不包括**在方法内部声明的局部变量。

Java中一个字段包含的信息：字段的作用域（public、private、protected修饰 符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰 符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类 型、对象、数组）、字段名称。

描述符的作用是 用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描 述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表 无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来 表示，详见表

![Snipaste_2019-04-08_09-25-16.jpg](https://i.loli.net/2019/04/08/5caaa31143e2b.jpg)

对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义 为“java.lang.String[][]”类型的二维数组，将被记录为：“[[Ljava/lang/String；”，一个整型数 组“int[]”将被记录为“[I”。

用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的 严格顺序放在一组小括号“（）”之内。如方法void inc（）的描述符为“（）V”，方法 java.lang.String toString（）的描述符为“（）Ljava/lang/String；”，方法int indexOf（char[]source,int sourceOffset,int sourceCount,char[]target,int targetOffset,int targetCount,int fromIndex）的描述符为“（[CII[CIII）I”。 

### 6.3.6 方法表集合

方法表结构包括：访问标志（access_flags）、名称索引（name_index）、描述符索 引（descriptor_index）、属性表集合（attributes）几项，详见表
![Snipaste_2019-04-08_09-49-55.jpg](https://i.loli.net/2019/04/08/5caaa8cee7c54.jpg)

### 6.3.7 属性表集合

在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。
![Snipaste_2019-04-08_20-24-09.jpg](https://i.loli.net/2019/04/08/5cab3db4c82b8.jpg)
![Snipaste_2019-04-08_20-24-39.jpg](https://i.loli.net/2019/04/08/5cab3ef4e27d3.jpg)
![Snipaste_2019-04-08_20-24-51.jpg](https://i.loli.net/2019/04/08/5cab3ef63fedc.jpg)

## 6.4 字节码指令简介

**Java虚拟机的指令**由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构成。

### 6.4.1 字节码与数据类型

在Java虚拟机指令集中，大多数的指令都包含了其操作所对应的数据数据类型信息。

对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：i代表对int类型的数据操作，l代表long,s代表short,b代表byte,c代表char,f代表float,d代表double,a代表reference。也有一些指令的助记符中没有明确地指明操作类型的字母，如arraylength指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。还有另外一些指令，如无条件跳转指令goto则是与数据类型无关的。

由于Java虚拟机的操作码长度只有一个字节，如果每一种与数据类型相关的指令都支持Java虚拟机所有运行时 数据类型的话，那指令的数量恐怕就会超出一个字节所能表示的数量范围了。因此并非每种数据类型和每一种操作都有对应的指令，有一些单独的指令可以在必要的时候用来将 一些不支持的类型转换为可被支持的类型。 

Java虚拟机所支持的与数据类型相关的字节码指令如图所示，通过使用数据类型列 所代表的特殊字符替换opcode列的指令模板中的T，就可以得到一个具体的字节码指令。
![Snipaste_2019-04-08_20-56-21.jpg](https://i.loli.net/2019/04/08/5cab4521dbe0e.jpg)
![Snipaste_2019-04-08_20-56-48.jpg](https://i.loli.net/2019/04/08/5cab45242fe47.jpg)

### 6.4.2 加载和存储指令

**加载和存储指令**用于将数据在栈帧中的局部变量表和操作数栈之间来回传输。

* 将一个局部变量加载到操作栈：iload、iload_＜n＞、lload、lload_＜n＞、fload、fload_ ＜n＞、dload、dload_＜n＞、aload、aload_＜n＞。
*  将一个数值从操作数栈存储到局部变量表：istore、istore_＜n＞、lstore、lstore_＜n＞、 fstore、fstore_＜n＞、dstore、dstore_＜n＞、astore、astore_＜n＞。 _
* _将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、 iconst_m1、iconst_＜i＞、lconst_＜l＞、fconst_＜f＞、dconst_＜d＞。 
* 扩充局部变量表的访问索引的指令：wide。 

注：有一部分是以尖括号结尾的（例如iload_＜n＞），这些指 令助记符实际上是代表了一组指令（例如iload_＜n＞，它代表了iload_0、iload_1、iload_2和 iload_3这几条指令）。

### 6.4.3 运算指令

**运算或算数指令**用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。大体上算术指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运 算的指令，由于没有直接支持byte、 short、char和boolean类型的算术指令，对于这类数据的运算，应使用操作int类型的指令代 替。整数与浮点数的算术指令在溢出和被零除的时候也有各自不同的行为表现，所有的算术 指令如下。 

* 加法指令：iadd、ladd、fadd、dadd。 
* 减法指令：isub、lsub、fsub、dsub。 
* 乘法指令：imul、lmul、fmul、dmul。 
* 除法指令：idiv、ldiv、fdiv、ddiv。 
* 求余指令：irem、lrem、frem、drem。 
* 取反指令：ineg、lneg、fneg、dneg。 
* 位移指令：ishl、ishr、iushr、lshl、lshr、lushr。 
* 按位或指令：ior、lor。 按位与指令：iand、land。 
* 按位异或指令：ixor、lxor。 
* 局部变量自增指令：iinc。 
* 比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp。 

在对long类型数值进行比较时，虚拟机采用带符号的比较方式，而对浮点数值进行比较 时（dcmpg、dcmpl、fcmpg、fcmpl），虚拟机会采用IEEE 754规范所定义的无信号比较 （Nonsignaling Comparisons）方式。

### 6.4.4 类型转换指令

**类型转换指令**：将两种不同的数值类型进行相互转换。

Java虚拟机直接支持（即转换时无需显式的转换指令）以下数值类型的宽化类型转换 （Widening Numeric Conversions，即小范围类型向大范围类型的安全转换）： 

* int类型到long、float或者double类型。 
* long类型到float、double类型。 
* float类型到double类型。 

相对的，处理窄化类型转换（Narrowing Numeric Conversions）时，必须显式地使用转换 指令来完成，在将一个浮点值窄化转换为整数类型T（T限于int或long类型之一）的时候，将遵循以下 转换规则： 

* 如果浮点值是NaN，那转换结果就是int或long类型的0。
*  如果浮点值不是无穷大的话，浮点值使用IEEE 754的向零舍入模式取整，获得整数值 v，如果v在目标类型T（int或long）的表示范围之内，那转换结果就是v。
*  否则，将根据v的符号，转换为T所能表示的最大或者最小正数。 

如果转换结果的绝对值太小而无 法使用float来表示的话，将返回float类型的正负零。如果转换结果的绝对值太大而无法使用 float来表示的话，将返回float类型的正负无穷大，对于double类型的NaN值将按规定转换为 float类型的NaN值。 

### 6.4.5 对象创建与访问指令

虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的 字节码指令。对象创建后，就可 以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令如下

* 创建类实例的指令：new。

*  创建数组的指令：newarray、anewarray、multianewarray。 
* 访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变 量）的指令：getfield、putfield、getstatic、putstatic。 
* 把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、 faload、daload、aaload。 
* 将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、 fastore、dastore、aastore。 
* 取数组长度的指令：arraylength。 
* 检查类实例类型的指令：instanceof、checkcast。

### 6.4.6 操作数栈管理指令

Java虚拟机提供了一些用于直接操作操作数 栈的指令，包括：

* 将操作数栈的栈顶一个或两个元素出栈：pop、pop2。 
* 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、 dup_x1、dup2_x1、dup_x2、dup2_x2。
*  将栈最顶端的两个数值互换：swap。

### 6.4.7 控制转移指令

控制转移指令可以让Java虚拟机有条件或无条件地从指定的位置指令而不是控制转移指 令的下一条指令继续执行程序，从概念模型上理解，可以认为控制转移指令就是在有条件或 无条件地修改PC寄存器的值。控制转移指令如下。 

* 条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、 if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne。 
* 复合条件分支：tableswitch、lookupswitch。 
* 无条件分支：goto、goto_w、jsr、jsr_w、ret。 

### 6.4.8 方法调用指令和返回指令

方法调用指令：

* invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分 派），这也是Java语言中最常见的方法分派方式。 
* invokeinterface指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对 象，找出适合的方法进行调用。
*  invokespecial指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有 方法和父类方法。 
* invokestatic指令用于调用类方法（static方法）。 
* invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方 法，前面4条调用指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻 辑是由用户所设定的引导方法决定的。 

方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括 ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和 areturn，另外还有一条return指令供声明为void的方法、实例初始化方法以及类和接口的类初 始化方法使用。

### 6.4.9 异常处理指令

在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现，除了用throw语 句显式抛出异常情况之外，Java虚拟机规范还规定了许多运行时异常会在其他Java虚拟机指 令检测到异常状况时自动抛出。例如，在前面介绍的整数运算中，当除数为零时，虚拟机会 在idiv或ldiv指令中抛出ArithmeticException异常。 

而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的（很久之前曾经 使用jsr和ret指令来实现，现在已经不用了），而是采用异常表来完成的。

### 6.4.10 同步指令

Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都 是使用管程（Monitor）来支持的。

**方法级的同步**是隐式的，即无须通过字节码指令来控制，它实现在方法调用和返回操作 之中。虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个 方法是否声明为同步方法。当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法， 最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线 程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出 了异常，并且在方法内部无法处理此异常，那么这个同步方法所持有的管程将在异常抛到同 步方法之外时自动释放。 

**同步一段指令集序列**通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的 指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义，正确实现 synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持，譬如代码清单6-6中所 示的代码。 （编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必 须执行其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束。 ）

## 6.5 公有设计和私有实现

Java虚拟机规范描绘了Java虚拟机应有的共有程序存储格式：**Class文件格式**以及**字节码指令集**。这些内容与硬件、操作系统及具体的Java虚拟机实现之间 完全独立的，因此它们可以看作是Java平台实现之间相互安全地交互手段。

公有设计和私有实现：Java虚拟机实现必须能够读取 Class文件并精确实现包含在其中的Java虚拟机代码的语义。一个优秀的虚拟机实现，在满足虚拟机 规范的约束下对具体实现做出修改和优化也是完全可行的，。只要优化后Class文件依然可以被正确读取，并且包含在其中的语义能得到完整的 保持，那实现者就可以选择任何方式去实现这些语义，虚拟机后台如何处理Class文件完全是 实现者自己的事情，只要它在外部接口上看起来与规范描述的一致即可。

虚拟机实现者可以使用这种伸缩性来让Java虚拟机获得更高的性能、更低的内存消耗或 者更好的可移植性，选择哪种特性取决于Java虚拟机实现的目标和关注点是什么。虚拟机实 现的方式主要有以下两种：

* 将输入的Java虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集。 
* 将输入的Java虚拟机代码在加载或执行时翻译成宿主机CPU的本地指令集（即JIT代码生 成技术）。 

## 6.6 Class文件结构的发展

Class文件结构自Java虚拟机规范第1版订立以来，已有十多年的历史，相对于语言、API以及Java技术体系中其他方面的变化，Class文件结构一直处于比较稳定的状态，Class文件的主体结构、字节码指令的语义和数量几乎没有出现过变动，所有对Class文件格式的改 进，都集中在向**访问标志、属性表**这些在设计上就可扩展的数据结构中添加内容。 

如果以《Java虚拟机规范（第2版）》为基准进行比较的话，那么在后续Class文件格式 的发展过程中，访问标志里新加入了ACC_SYNTHETIC、ACC_ANNOTATION、 ACC_ENUM、ACC_BRIDGE、ACC_VARARGS共5个标志。而属性表集合中，在JDK 1.5到 JDK 1.7版本之间一共增加了12项新的属性，这些属性大部分用于支持Java中许多新出现的语 言特性，如枚举、变长参数、泛型、动态注解等。还有一些是为了支持性能改进和调试信 息，譬如JDK 1.6的新类型校验器的StackMapTable属性和对非Java代码调试中用到的 SourceDebugExtension属性。 

Class文件格式所具备的**平台中立**（不依赖于特定硬件及操作系统）、**紧凑**、**稳定**和**可扩 展**的特点，是Java技术体系实现**平台无关、语言无关**两项特性的重要支柱。

## 6.7 本章小结

Class文件是Java虚拟机执行引擎的数据入口，也是Java技术体系的基础构成之一。

