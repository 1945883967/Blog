# 第八章 虚拟机字节码执行引擎

代码编译的结果从本地机器码转变为字节码，是存储格式的一小步，却是编程语言的一大步。

## 8.1 概述

执行引擎是Java虚拟机最核心的组成部分之一。“虚拟机”是一个相对于“物理机”的概念，这两种机器都有**代码执行能力**，其区别是物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，而虚拟机的执行引擎则是自己实现的，因此可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。

在Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型成为各种 虚拟机执行引擎的统一外观（Facade）。在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，也可两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎。从外观来看，所有的java虚拟机执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出是执行结果。

## 8. 2 运行时栈帧结构

**栈帧（Stack Frame）**：是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（VirtualMachine Stack）的元素。每一个栈帧都包括了方法的局部变量表、操作数栈、动态链接和方法放回地址和一些额外的附加信息。每一个方法从调用开始至执行完成的过程，对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。

对于执行引擎来说，在线程活动中，只有位于栈顶的栈帧才是有效的，称为**当前栈帧（Current Stack Frame）**，与这个栈帧相关联的方法称之为**当前方法（Current Method）**。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如图：
![Snipaste_2019-04-11_19-40-45.jpg](https://i.loli.net/2019/04/11/5caf27d0bbbd0.jpg)

### 8.2.1 局部变量表

**局部变量表（Local Variable）**：是一组变量值存储空间，用于存放参数和方法内的部定义的局部变量。局部变量表的最大容量在Java程序编译为Class文件时，在方法的Code属性的max_locals数据项中就已经确定。

局部变量表的容量以**变量槽（Variable Slot，下称Slot）**为最小单位，每个Slot都应该能存放一 个boolean、byte、char、short、int、float、reference或returnAddress类型的数据，这8种数据类 型，都可以使用32位或更小的物理内存来存放，Slot的长度可以随着处理器、操作系统或虚拟机的不 同而发生变化。

一个Slot可以存放 一个32位以内的数据类型，Java中占用32位以内的数据类型有boolean、byte、char、short、 int、float、reference[3]和returnAddress 8种类型。前六种，可以按照Java 语言中对应数据类型的概念去理解它们（仅是这样理解而已，Java语言与Java虚拟机中的基 本数据类型是存在本质差别的），第7种reference类型表示对一个对象实例的引用，虚拟机 规范既没有说明它的长度，也没有明确指出这种引用应有怎样的结构。但虚拟机 实现至少都应当能通过这个引用做到两点，一是从此引用中直接或间接地查找到对象在Java 堆中的数据存放的起始地址索引，二是此引用中直接或间接地查找到对象所属数据类型在方 法区中的存储的类型信息。第8种即 returnAddress类型，它是为字节码指令jsr、jsr_w和ret服务的，指向了一条 字节码指令的地址，很古老的Java虚拟机曾经使用这几条指令来实现异常处理，现在已经由 异常表代替。 

对于64位的数据类型，虚拟机会以高位对齐的方式为其分配两个连续的Slot空间。Java 语言中明确的（reference类型则可能是32位也可能是64位）64位的数据类型只有long和double 两种。

虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最 大的Slot数量。

在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如 果执行的是实例方法（非static的方法），那局部变量表中第0位索引的Slot默认是用于传递方 法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体 内部定义的变量顺序和作用域分配其余的Slot。 

为了尽可能节省栈帧空间，局部变量表中的Slot是可以重用的。（细节见书p239）

类变量有两次赋初始值的过 程，一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的初始值。因此，即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量（由static修饰的）仍然具有一个确定的初始值。但局部变量就不一样，如果一个局部变量定义了但没有赋初始值是不能使用 的，不要认为Java中任何情况下都存在诸如整型变量默认为0，布尔型变量默认为false等这样 的默认值。

### 8.2.2 操作数栈

**操作数栈（Operand Stack）**也常称为操作栈，它是一个后入先出（Last In First Out,LIFO）栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的 max_stacks数据项中。操作数栈的每一个元素可以是任意的Java数据类型，包括long和 double。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。在方法执行的任 何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。

当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中， 会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。例如，在做算术运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。 

### 8.2.3 动态连接

每个栈帧都包含一个指向运行时常量池[1]中该栈帧所属方法的引用，持有这个引用是为 了支持方法调用过程中的**动态连接（Dynamic Linking）。**Class 文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符 号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接 引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称 为动态连接。

### 8.2.4 方法返回地址

当一个方法开始执行后，只有两种方式可以退出这个方法。第一种方式是执行引擎遇到 任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当 前方法的方法称为调用者），是否有返回值和返回值的类型将根据遇到何种方法返回指令来 决定，这种退出方法的方式称为**正常完成出口（Normal Method Invocation Completion）。** 

另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得 到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异 常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出 方法的方式称为**异常完成出口（Abrupt Method Invocation Completion）**。一个方法使用异常 完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。

无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能 继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行 状态。一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可 能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。 方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复 上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈 中，调整PC计数器的值以指向方法调用指令后面的一条指令等。

### 8.2.5　附加信息 

虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发 中，一般会把**动态连接、方法返回地址与其他附加信息**全部归为一类，称为**栈帧信息**。

## 8.3 方法调用

