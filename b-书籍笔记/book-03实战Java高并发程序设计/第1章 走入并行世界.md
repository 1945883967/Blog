# 第1章 走入并行世界
## 1.2 几个基本概念
### 1.2.1 同步（Synchronous）和异步（Asynchronous）
同步和异步通常用来形容一次方法的调用。
同步方法调用一旦开始，调用者必须等到方法调用返回后，才能执行后续的行为。
异步方法调用更像一次消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续执行后续的操作，而异步方法通常会在另一个线程中：真实“的执行。整个过程不会妨碍调用者的工作。

### 1.2.2 并发（Concurrency）和并行（Parallelism）

它们都可以表示两个或多个任务一起执行，但是偏重点不同。并发偏重于多个任务交替执行，而多个任务之间有可能是串行的。而并行是真正意义上的”同时执行“。
![Snipaste_2019-06-05_10-11-16.jpg](https://i.loli.net/2019/06/05/5cf724e1593f980669.jpg)

严格意义上来讲，并行的多个任务是真正的真实的同时进行，而对于并发来说，这个过程只是交替的，一会儿运行任务A一会儿运行任务B，系统不停的两两者间切换，但对于外部观察者来说，即时多个任务是串行并发的，也会造成任务间是并行执行的错觉。

### 1.2.3 临界区

临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每一次，只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源，就必须等待。

### 1.2.4 阻塞(Blocking)和非阻塞(Non-Blocking)

阻塞和非阻塞通常用来形容多线程间的相互影响。比如一个线程占用了临界区资源，那么其他所有需要这个资源的线程就必须在这个临界区中进行等待。等待会导致线程的挂起，这种情况就是阻塞。此时如果占用资源的线程一直不愿意释放资源，那么其他所有阻塞在这个临界区上的线程都不能工作。

非阻塞的意思与此相反，它强调没有一个线程可以妨碍其他线程执行。所有的线程都过尝试不断前向执行。

### 1.2.5 死锁(Deadlock)、饥饿(Starvation)和活锁(Livelock)

死锁、饥饿和活锁都属于多线程的活跃性问题。如果发现上述几种情况，那么相关线程可能就不在活跃，也就是说它可能很难在继续执行了。

饥饿是指某一个或者多个线程因为种种原因无法获取所需要的资源，导致一直无法执行。

活锁同样会发生在多个相互协作的线程间，当他们为了彼此间的响应而相互礼让，使得没有一个线程能够继续前进，那么就发生了活锁。

## 1.3 并发界别

阻塞、无饥饿、无障碍、无锁、无等待

### 1.3.1 阻塞(Blocking)

一个线程是阻塞的，那么在其他线程释放资源之前，当前线程无法继续执行。当我们使用synchronized关键字或重入锁时，我们得到的就是线程的阻塞。

### 1.3.2 无饥饿(Starvation-Free)

如果线程之间是有优先级的，那么线程调度的时候总是会倾向于满足高优先级的线程。

如果锁考虑线程的优先级，那么对于要使用的同一资源，总是有高优先级的先占用（允许高优先级线程插队），对于低优先级的线程此时就会产生饥饿。

### 1.3.3 无障碍(Obstruction-Free)
![Snipaste_2019-06-05_11-09-19.jpg](https://i.loli.net/2019/06/05/5cf732691ecdf58716.jpg)

### 1.3.4 无锁(Lock-Free)

无锁的并行都是无障碍的。在无锁的情况下，所有的线程都尝试多临界区进行访问，但不同的是，无锁的并发保证必然有一个线程能够在有限步内完成操作离开临界区。

### 1.3.5 无等待(Wait-Free)

无锁要求一个线程可以在有限步内完成操作，无等待则在无锁的基础上更进一步进行扩展。它要求所有的线程必须在有限补内完成，这样就不会产生饥饿的问题。

## 1.4 有关并行的两个定律

### 1.4.1 Amdahl定律

**Amdahl**:定义了串行系统并行化后的加速比的计算公式和理论上限。

加速比定义：加速比= 优化前系统耗时/优化后系统耗时

加速比越高系统优化越明显。

### 1.4.2 Gustafson定律

## 1.5 回到Java：JVM
Java的关键技术点都是围绕着多线程的原子性、可见性、和有序性来建立的。

### 1.5.1 原子性(Atomicity)

原子性是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。

### 1.5.2 可见性(Visibility)

可见性是指当一个线程修改了某一变量的值，其他线程是否能够立即知道这个修改。

### 1.5.3 有序性(Ordeing)

指令流水线    指令重排

指令重排不能违背的原则：

* 程序的顺序原则：一个线程内保证语义的串行性。
* volatile规则：volatile变量的写，先发生于读，这保证了volatile变量的可见性
* 锁规则：解锁(unlock)必然发生在随后的加锁(lock)前。
* 传递性：A先于B，B先于C，那么A必然先于C。
* 线程的start()方法先于它的每一个动作。
* 线程的所有操作优先于线程的终结(Thread.join())
* 线程的中断(interrupt())先于被中断的代码。
* 对象的构造函数执行、结束先于finalize()方法。





