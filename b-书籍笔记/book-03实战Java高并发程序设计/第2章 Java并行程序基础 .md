# 第2章 Java并行程序基础

## 2.1 有关线程你必须知道的事

**进程（Process）**是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。

线程是轻量级的进程，是程序执行的最小单位。使用多线程而不是使用多进程去进行并发程序的设计，是因为线程间的切换和调度的成本远远小于进程。

线程的生命周期：
![Snipaste_2019-06-11_10-46-53.jpg](https://i.loli.net/2019/06/11/5cff162aeddb794889.jpg)

线程的所有状态都在Thread中的State枚举中定义，如下s所示：

```java
    public enum State {  
        NEW,
        BLOCKED,     
        WAITING,  
        TIMED_WAITING,
        TERMINATED;
    }
```

![Snipaste_2019-06-11_11-02-01.jpg](https://i.loli.net/2019/06/11/5cff19b10be5610345.jpg)

## 2.2 初始线程：线程的基本操作

### 2.2.1 新建线程

通过new关键字可以新建一个线程对象，然后用此对象调用start()方法即可启动一个线程。线程Thread有一个run()方法，start()方法执行后会新建一个线程并让这个线程执行run()方法。如果直接用线程对象调用run()方法，不能创建一个线程，只是作为一个普通方法调用。

### 2.2.2 终止线程

使用stop()方法可以将一个线程终止(此方法已过时)。

注：使用stop()方法终止线程，可能会引起数据不一致的问题。
![Snipaste_2019-06-12_12-12-30.jpg](https://i.loli.net/2019/06/12/5d007bbe161f670686.jpg)

### 2.2.3 线程中断

```java
public void Thread.interrupt()              // 中断线程
public boolean Thread.isInterrupted()       // 测试线程是否已经中断。
public static boolean Thread.interrupred()  //判断是否被中断，并清除当前中断状态
```

注：p38

### 2.2.4 等待(wait)和通知(notify)

wait()和notify()作用为了支持多线程之间的协作。这两个方法在Object类中，而不是在Thread类中。

当一个对象实例上调用wait()方法后，当前线程就会在这个对象上等待。（实际上这个对象可能会被多个线程调用，因此会有一个等待队列，当某个线程调用这个方法时就进入了该对象的等待队列。）（例：线程A中，调用了obj.wait()方法，那么线程A就会停止继续执行，而转为等待状态。线程A一直等到其他线程调用了obj.notify()方法为止。当其他线程调用notify()方法后，会从对象的等待队列中随机唤醒一个线程，是不公平的，不是先等待的先被唤醒，这个选择完全是随机的）Object()还有一个类似的notifyAll()方法，能唤起队列中所有等待的线程而不是随机选择一个。
![Snipaste_2019-06-12_17-52-38.jpg](https://i.loli.net/2019/06/12/5d00cb91745da43223.jpg)

Object.wait()方法不是随机调用的，它必须包含在对应饿Synchronzied语句中，无论是wait()还是notify()都需要首先获得目标对象的监视器（就是同步代码块中关键字Synchronzied后括号的的对象，也称同步锁）。

![Snipaste_2019-06-12_17-52-55.jpg](https://i.loli.net/2019/06/12/5d00cb921f9ba76957.jpg)

注：监视器（同步锁）：

* 对于同步代码块是关键字Synchronzied后括号内指定的任意对象。
* 对于同步非静态方法，同步锁是this。
* 对于同步静态方法，同步锁是方法所在类的字节码对象(类名.class)。

ps：Object.wait()和Thread.sleep()方法都可以让线程等待若干时间，区别如下：

* Object.wait()方法让线程等待后，可以被唤醒，除此之外wait()方法会释放目标对象的锁。
* Thread.sleep()方法让线程等待后，不可以被唤醒，sleep()方法不会释放任何资源。

### 2.2.5 挂起(suspend)和继续执行(resume)线程
![Snipaste_2019-06-12_19-38-00.jpg](https://i.loli.net/2019/06/12/5d00e43f2988537873.jpg)

###　2.2.6 等待线程结束(join)和谦让(yield)

一个线程的输入可能非常依赖于另一个或多个线程的输出，此时，这个线程就需要等待依赖线程执行完毕，才能继续执行，Java中使用join()操作来完成这个功能，英文join翻译为加入，一个线程要等待另外一个线程，那么最好的方法就是等他一起走。join()的本质是让调用线程wait()在当前线程对象的实例上，方法如下：

```java
public final synchronized void join() 
public final synchronized void join(long millis)
```

第一个join()方法表示无限等待，他会一直阻塞当前线程，直到目标线程执行完毕。

第二个方法给出一个最大等待时间，如果超过给定的时间目标线程还未执行，当前线程也会因为“等不及了”，而继续向下执行。

**注：第一次理解不充分，日后需揣摩p49**

Thread.yield()方法：

```java
public static native void yield()
```

这是一个静态方法，一旦执行，他会使当前线程让出CPU。

注意：让出CPU并不表示当前线程不执行了。当前线程在让出CPU后，还会进行CPU资源的争夺，但是否能够再次分配到，就不一定了。因此，对Thread.yield()的调用就好像是说：我已经完成了一些重要的工作了，我应该休息一下了，可以给其他线程一些工作机会了。

##  2.3 volatile与java内存模型（JMM)

java内存模型(JMM)是围绕着原子性、有序性和可见性展开的。为了在适当的场合，确保线程间的有序性、可见性和原子性。Java使用了一些特殊的操作和关键字来声明、告知虚拟机，在这个地方，需尤其注意，不能随意变动优化目标指令。关键字volatile就是其中之一。

英文volatile的意思是“易变的，不稳定的”，这也正是关键字volatile的语义。

当用volatile去声明一个变量使，就等于告诉了虚拟机，这个变量极有可能会被某些程序或线程修改。为确保这个变量被修改后，应用程序范围内的所有线程都能够“看到”这个改动，虚拟机就必须采用一些特殊的手段，保证这个变量的可见性等特点。

volatile保证变量的可见性,但是无法保证一些**符合操作**的原子性

